# Huffman Coding Algorithm


## What is Huffman Coding

Huffman code is a particular type of optimal prefix code that is commonly used for lossless data compression. It uses variable length encoding where variable length codes are assigned to all the characters depending on how frequently they occur in the given text.

*Here, we will be able to achieve the size ratio of 2:1 for original text file to compressed text file.*

## Steps

**Step1** - Getting the frequency of all characters present in the text file. The frequency of each character is stored in a dictionary(HASHMAP).

**Step2** - Building a min heap on this dictionary. The characters with minimum frequency are present above in the heap. Binary Tree Nodes having the character and frequency are used as heap elements. 

**Step3** - Building a binary tree then helps in the generation of codes. A binary tree is generated by getting the two minimum entries(let's say A1 and A2) from the heap with the minimum frequency. These two frequencies are combined and a new node is created and this new node has A1 and A2 as its left and right child. Complete tree is build using all the elements of the heap.

**Step4** - Now to get the codes we run over our new Binary Tree constructed on the previous steps. All of our nodes with character values are leaf node. Getting to them generates their individual code and since they are leaf nodes, it ensures that no two characters have the same prefix codes. To get the code for a character, we go over the path from root to that particular node. If in path a node is to left of its parent then we add '0' to our code and if a node is to the right of its parent, we add '1' to the code of that character. We store all the codes in two different mappings. One to encode the text i.e. a code dictionary of character to their codes, and the other to decode the text i.e. a dictionary of codes to character. 

**Step5** - Now the actual encoding of the text takes place here. We should probably know by now that all our characters have binary values(in for of 0's and 1's). Now for each character in the text, we get its code and form the overall encoded text for input file.

**Step6** - Now the padding of the encoded text is done. If the encoded text's length is not in multiples of 8 we append the required number of 0's at the end. Now to know the exact number of zeros we appended, we add another 8-bit number at the front of our encoded text.

**Step7** - After getting the padded encoded text, we convert the binary file into a bytes and store the new file as compressed file.

**Step8** - Now, for decompression part, we first convert the bytes data in the file to bits. Then we remove the padding at front and end of our encoded text. After this, we traverse throught our bits and use our reverse codes dictionary to generate back the decompressed text file.
